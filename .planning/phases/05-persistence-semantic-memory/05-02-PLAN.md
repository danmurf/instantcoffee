---
phase: 05-persistence-semantic-memory
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/memory.ts
  - src/db/memories.ts
  - src/hooks/useMemories.ts
  - src/components/MemoryPanel.tsx
autonomous: true
must_haves:
  truths:
    - "User can add memories about services, teams, and preferences via a dedicated panel"
    - "User can edit and delete existing memories from the panel"
    - "Memories persist in IndexedDB across browser sessions"
    - "Memory panel shows all stored memories organized by category"
  artifacts:
    - path: "src/types/memory.ts"
      provides: "Memory type definitions"
      exports: ["Memory", "MemoryCategory"]
    - path: "src/db/memories.ts"
      provides: "Memory CRUD operations"
      exports: ["createMemory", "updateMemory", "deleteMemory", "listMemories", "getAllMemoriesForPrompt"]
    - path: "src/hooks/useMemories.ts"
      provides: "Reactive memory list hook and chat command parsing"
      exports: ["useMemories"]
    - path: "src/components/MemoryPanel.tsx"
      provides: "Memory management UI panel"
      min_lines: 80
  key_links:
    - from: "src/hooks/useMemories.ts"
      to: "src/db/memories.ts"
      via: "CRUD operations and useLiveQuery"
      pattern: "useLiveQuery"
    - from: "src/components/MemoryPanel.tsx"
      to: "src/hooks/useMemories.ts"
      via: "uses hook for memory operations"
      pattern: "useMemories"
---

<objective>
Create semantic memory storage, CRUD operations, and a dedicated memory management panel.

Purpose: Users can store knowledge about their infrastructure (services, teams, preferences) that persists across sessions. This plan handles the storage layer and the panel UI. Chat-based memory commands and prompt injection are wired in plan 03.
Output: Memory types, database operations, reactive hook, and a visual memory panel component.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistence-semantic-memory/05-CONTEXT.md
@.planning/phases/05-persistence-semantic-memory/05-RESEARCH.md
@src/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Memory types, database operations, and reactive hook</name>
  <files>
    src/types/memory.ts
    src/db/memories.ts
    src/hooks/useMemories.ts
  </files>
  <action>
    1. Create `src/types/memory.ts`:
       - `type MemoryCategory = 'service' | 'team' | 'preference' | 'general'`
       - `interface Memory`:
         - `id?: number` (Dexie auto-increment)
         - `category: MemoryCategory`
         - `name: string` (e.g., "auth-service", "Platform Team")
         - `content: string` (description, details, ownership info)
         - `createdAt: number`
         - `updatedAt: number`

    2. Create `src/db/memories.ts`:
       - Import `db` from `@/db/index`
       - `createMemory(category: MemoryCategory, name: string, content: string): Promise<number>` — sets createdAt/updatedAt to Date.now()
       - `updateMemory(id: number, updates: Partial<Pick<Memory, 'category' | 'name' | 'content'>>): Promise<void>` — merges updates, sets updatedAt
       - `deleteMemory(id: number): Promise<void>`
       - `listMemories(): Promise<Memory[]>` — all memories ordered by category then name
       - `getAllMemoriesForPrompt(): Promise<string>` — returns a formatted string of all memories suitable for injection into the system prompt. Format each memory as: `- [category] name: content`. Returns empty string if no memories exist.

    3. Create `src/hooks/useMemories.ts`:
       - Uses `useLiveQuery` from `dexie-react-hooks` to reactively query all memories
       - Exposes:
         - `memories: Memory[] | undefined`
         - `addMemory(category: MemoryCategory, name: string, content: string): Promise<void>`
         - `editMemory(id: number, updates: Partial<Pick<Memory, 'category' | 'name' | 'content'>>): Promise<void>`
         - `removeMemory(id: number): Promise<void>`
       - Also export a `parseMemoryCommand(text: string): { action: 'remember' | 'forget' | 'update', name: string, content: string } | null` function:
         - Matches patterns like:
           - "remember that auth-service is owned by Platform team" -> { action: 'remember', name: 'auth-service', content: 'owned by Platform team' }
           - "forget about auth-service" -> { action: 'forget', name: 'auth-service', content: '' }
           - "update: auth-service now runs on GCP" -> { action: 'update', name: 'auth-service', content: 'now runs on GCP' }
         - Returns null if text doesn't match any memory command pattern
         - Use simple regex: `/^remember\s+that\s+(.+?)\s+is\s+(.+)$/i`, `/^forget\s+(?:about\s+)?(.+)$/i`, `/^update:\s*(.+?)\s+(.+)$/i`
  </action>
  <verify>
    `npm run build` succeeds. All exports resolve correctly.
  </verify>
  <done>
    Memory types defined. CRUD operations work against Dexie. Reactive hook provides live memory list. Chat command parser can detect remember/forget/update patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Memory management panel UI</name>
  <files>src/components/MemoryPanel.tsx</files>
  <action>
    Create `src/components/MemoryPanel.tsx`:

    A panel component for managing memories. It will be mounted inside the session sidebar in plan 03, but is self-contained for now.

    Props: none (uses useMemories hook internally)

    Layout:
    - Header: "Memories" title with an "Add" button
    - Add form (shown when "Add" clicked, toggle visibility):
      - Category dropdown (service, team, preference, general)
      - Name input (text field)
      - Content textarea
      - "Save" and "Cancel" buttons
    - Memory list grouped by category:
      - Category headers (capitalize first letter)
      - Each memory shows name (bold) and content (gray text below)
      - Each memory has edit (pencil icon) and delete (trash icon) buttons
      - Edit mode: inline editing with same fields as add form, "Save" and "Cancel"
    - Delete confirmation: simple `window.confirm()` dialog
    - Empty state: "No memories yet. Add information about your services, teams, and preferences."

    Styling: Tailwind CSS matching existing app style (white bg, gray-200 borders, indigo-600 for primary actions). Compact layout suitable for sidebar placement.

    Use functional state management: `editingId: number | null`, `isAdding: boolean`, form state with useState.
  </action>
  <verify>
    `npm run build` succeeds. The component can be temporarily rendered in App.tsx to verify it displays correctly (or verify through build alone).
  </verify>
  <done>
    MemoryPanel renders a complete memory management UI with add, edit, delete, and category grouping. All operations persist to IndexedDB via the useMemories hook.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. Memory types, CRUD, hook, and panel component all exist
3. `parseMemoryCommand` correctly parses remember/forget/update patterns
4. `getAllMemoriesForPrompt` returns formatted memory string
5. MemoryPanel has add, edit, delete functionality with category grouping
</verification>

<success_criteria>
- Memory CRUD operations persist to IndexedDB
- Reactive hook auto-updates when memories change
- Memory panel provides full management UI (add, edit, delete, category grouping)
- Chat command parser detects memory-related natural language
- getAllMemoriesForPrompt formats memories for system prompt injection
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistence-semantic-memory/05-02-SUMMARY.md`
</output>
