---
phase: 05-persistence-semantic-memory
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/components/SessionSidebar.tsx
  - src/components/Layout.tsx
  - src/components/ChatPanel.tsx
  - src/hooks/useChat.ts
  - src/App.tsx
autonomous: false
must_haves:
  truths:
    - "User can see a collapsible sidebar with session list showing name and last modified date"
    - "User can click a session to load it and continue working"
    - "When switching sessions with unsaved changes, user sees a warning"
    - "User can delete sessions with a confirmation dialog"
    - "User can create a new session (auto-saves current, starts blank)"
    - "User can manage memories via chat commands (remember, forget, update)"
    - "System includes all stored memories in every AI prompt"
    - "User can access the memory panel from the sidebar"
  artifacts:
    - path: "src/components/SessionSidebar.tsx"
      provides: "Collapsible sidebar with session list and memory panel"
      min_lines: 100
    - path: "src/components/Layout.tsx"
      provides: "Updated layout accommodating sidebar"
    - path: "src/hooks/useChat.ts"
      provides: "Memory injection into system prompt and chat command handling"
  key_links:
    - from: "src/components/SessionSidebar.tsx"
      to: "src/hooks/useSessions.ts"
      via: "displays reactive session list"
      pattern: "useSessions"
    - from: "src/hooks/useChat.ts"
      to: "src/db/memories.ts"
      via: "getAllMemoriesForPrompt injected into system prompt"
      pattern: "getAllMemoriesForPrompt"
    - from: "src/App.tsx"
      to: "src/components/SessionSidebar.tsx"
      via: "passes session switching and new session handlers"
      pattern: "SessionSidebar"
    - from: "src/hooks/useChat.ts"
      to: "src/hooks/useMemories.ts"
      via: "parseMemoryCommand for chat-based memory management"
      pattern: "parseMemoryCommand"
---

<objective>
Wire session sidebar UI, memory-in-chat commands, and memory injection into AI prompts. This is the integration plan that brings plans 01 and 02 together into a cohesive user experience.

Purpose: Users can switch between sessions, manage memories via chat or panel, and the AI always has memory context when generating diagrams.
Output: Complete persistence and semantic memory feature set — sidebar, session switching, chat memory commands, prompt injection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-persistence-semantic-memory/05-CONTEXT.md
@.planning/phases/05-persistence-semantic-memory/05-RESEARCH.md
@.planning/phases/05-persistence-semantic-memory/05-01-SUMMARY.md
@.planning/phases/05-persistence-semantic-memory/05-02-SUMMARY.md
@src/App.tsx
@src/hooks/useChat.ts
@src/components/Layout.tsx
@src/components/ChatPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session sidebar and layout integration</name>
  <files>
    src/components/SessionSidebar.tsx
    src/components/Layout.tsx
    src/App.tsx
  </files>
  <action>
    1. Create `src/components/SessionSidebar.tsx`:
       A ChatGPT-style collapsible sidebar on the left side of the app.

       Props:
       - `sessions: Session[]` (from useSessions)
       - `currentSessionId: number | null`
       - `hasUnsavedChanges: boolean`
       - `onSelectSession: (id: number) => void`
       - `onNewSession: () => void`
       - `onDeleteSession: (id: number) => void`
       - `isCollapsed: boolean`
       - `onToggleCollapse: () => void`

       Layout (when expanded, ~240px wide):
       - Top bar: hamburger/collapse button, "New Session" button (+ icon)
       - Session list (scrollable):
         - Each item shows session name (truncated) and relative last modified date (e.g., "2 hours ago", "Yesterday" — use a simple helper function, no library needed)
         - Active session highlighted with indigo-50 bg and indigo-600 left border
         - Hover shows delete button (trash icon)
         - Click to select (triggers onSelectSession which should check unsaved changes)
       - Bottom section: "Memories" toggle that expands/collapses the MemoryPanel component
       - Delete: `window.confirm('Delete this session? This cannot be undone.')` then calls onDeleteSession

       When collapsed (~48px wide):
       - Show only hamburger button and "+" button (icons only, no text)

       Styling: dark sidebar (gray-900 bg, gray-300 text) contrasting with the white main content area. Tailwind classes.

    2. Update `src/components/Layout.tsx`:
       - Add a `sidebar?: ReactNode` prop
       - If sidebar is provided, render it to the left of the existing two-panel layout
       - The sidebar should be outside the resizable split — it's a fixed-width element
       - Layout becomes: [Sidebar] | [Left Panel (chat)] | [Right Panel (whiteboard)]

    3. Update `src/App.tsx`:
       - Add sidebar collapse state: `const [sidebarCollapsed, setSidebarCollapsed] = useState(false)`
       - Import and use `useSessions` hook for reactive session list
       - Implement `handleSelectSession(id: number)`:
         - If `hasUnsavedChanges`, show `window.confirm('You have unsaved changes. Switch session anyway?')`
         - If confirmed (or no unsaved changes): flush auto-save, then call `loadSession(id)`, hydrate state via `loadSessionState`, set `currentSessionId`
       - Implement `handleDeleteSession(id: number)`:
         - Call `deleteSession(id)`. If deleting the current session, reset to new session state.
       - Wire `handleNewSession` (from plan 01) to sidebar
       - Render `<SessionSidebar>` into Layout's new sidebar prop
       - Render `<MemoryPanel>` inside the sidebar's memory section
  </action>
  <verify>
    `npm run build` succeeds. Open app in browser: sidebar appears on left with session list. Creating a new session via "+" button works. Clicking between sessions loads different state.
  </verify>
  <done>
    Collapsible sidebar displays sessions with name and last modified date. Users can create, switch, and delete sessions. Unsaved changes warning appears when switching. Memory panel accessible from sidebar.
  </done>
</task>

<task type="auto">
  <name>Task 2: Memory injection into prompts and chat-based memory commands</name>
  <files>
    src/hooks/useChat.ts
    src/components/ChatPanel.tsx
  </files>
  <action>
    1. Update `src/hooks/useChat.ts`:

       a. Memory injection into system prompt:
       - Import `getAllMemoriesForPrompt` from `@/db/memories`
       - In `toOllamaMessages`, make the function async
       - Before building the system message, call `const memoryContext = await getAllMemoriesForPrompt()`
       - If memoryContext is non-empty, append to SYSTEM_PROMPT:
         ```
         \n\nUSER'S CONTEXT (use this knowledge when generating diagrams):\n${memoryContext}
         ```
       - Update `sendMessage` to await the now-async `toOllamaMessages`

       b. Chat-based memory commands:
       - Import `parseMemoryCommand` from `@/hooks/useMemories`
       - Import `createMemory, updateMemory, deleteMemory` from `@/db/memories` and `db` from `@/db/index`
       - In `sendMessage`, BEFORE sending to Ollama, check `parseMemoryCommand(trimmedContent)`:
         - If result is not null:
           - For 'remember': call `createMemory('general', result.name, result.content)`. Add user message, then add an assistant message: "Got it! I'll remember that {name} {content}." Do NOT send to Ollama.
           - For 'forget': find memory by name (case-insensitive search via `db.memories.where('name').equalsIgnoreCase(result.name).first()`), if found call `deleteMemory(id)` and respond "Done, I've forgotten about {name}." If not found, respond "I don't have any memory about {name}."
           - For 'update': find memory by name, if found call `updateMemory(id, { content: result.content })` and respond "Updated! {name} — {content}." If not found, create it instead and respond "I didn't have a memory for {name}, so I've created one: {content}."
           - Return early (skip Ollama call) for all memory commands
         - If result is null: proceed with normal Ollama flow

    2. Update `src/components/ChatPanel.tsx`:
       - No functional changes needed, but update the example prompts to include one memory-related example:
         - Replace one of the existing examples with: "Remember that auth-service is owned by Platform team"
         - This hints to users that memory commands exist
  </action>
  <verify>
    `npm run build` succeeds. In the browser:
    1. Type "remember that auth-service is owned by Platform team" — should get confirmation without calling Ollama
    2. Open memory panel — auth-service should appear
    3. Type "create a diagram showing auth-service" — the system prompt sent to Ollama should include the memory context
    4. Type "forget about auth-service" — should get confirmation, memory removed
  </verify>
  <done>
    All stored memories are injected into every AI prompt. Users can manage memories via natural language chat commands (remember, forget, update). Chat panel includes a memory-related example prompt.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete session persistence and semantic memory system: auto-saving sessions, collapsible sidebar with session list, memory panel, chat-based memory commands, and memory injection into AI prompts.</what-built>
  <how-to-verify>
    1. Open http://localhost:5173
    2. Verify sidebar appears on the left with a "New Session" button
    3. Send a chat message like "Create a flowchart for user login" — diagram should render
    4. Check sidebar: session should appear with auto-generated name
    5. Click "+" to create new session — current session should auto-save, new blank session starts
    6. Switch back to the first session — chat history and diagram should restore
    7. Type "remember that auth-service is owned by Platform team" — should get confirmation
    8. Open memory panel in sidebar — memory should be listed
    9. Type "create a diagram showing auth-service architecture" — AI should use memory context
    10. Try "forget about auth-service" — memory should be removed
    11. Try deleting a session — should see confirmation dialog
    12. Collapse and expand the sidebar
    13. Close browser tab, reopen — sessions and memories should persist
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. Sessions auto-save and appear in sidebar
3. Session switching loads correct state with unsaved changes warning
4. New session auto-saves current, starts blank
5. Delete session works with confirmation
6. Memory panel allows add, edit, delete with category grouping
7. Chat memory commands (remember, forget, update) work
8. All memories injected into system prompt for every AI call
9. Data persists across browser sessions (IndexedDB)
</verification>

<success_criteria>
- Sidebar shows sessions with name + last modified, supports create/switch/delete
- Unsaved changes warning on session switch
- Memory panel accessible from sidebar with full CRUD
- Chat commands for remember/forget/update work without calling Ollama
- AI prompts include all stored memories
- Everything persists across browser refreshes
</success_criteria>

<output>
After completion, create `.planning/phases/05-persistence-semantic-memory/05-03-SUMMARY.md`
</output>
